/*********************
   functions I want
*********************/
// Array -> Function -> Array
// takes array and predicate, returns array with elements that satisfy predicate
function filter(arr, pred){
	let goodGuys = [];
	for (let elem of arr){
		if(pred(elem)){
			goodGuys.push(elem);
		}
	}
	return goodGuys;
}

/*********************
   React Components
*********************/
//cell in a table that has a button that says "delete"
function DelCell(props){
	return(
		<td>
			<button onClick={props.onClick}>
				Delete
			</button>
		</td>
	);
}

//cell in a table that one can write an expression in
function ExprCell(props){
	return (
		<td>
			<input 
				type="text"
				value={props.text}
				onChange={props.onChange} />
		</td>
	);
}

//cell that contains the output of the application of 
//   a relevent function to a relevent expression
// the function is called "expression" and the 
//    expression is called "inValue"
// I should probably change that at some point  
function TestCell(props){
	return (
		<td>
			{props.expression(props.inValue)}
		</td>
	);
}

//value mapping row
function IORow(props){
	return (
		<tr>
			<ExprCell
				text={props.inText}
				onChange={props.onChange} />
			{props.expressions.map((expr, index) => 
														<TestCell
															key={index}
															inValue={props.inValue}
															expression={expr}
															/>)}
			<DelCell
				onClick={props.onClick}
				/>
		</tr>
	);
}

//button that says "Test"
function TestButton(props){
	return (
		<button onClick={props.onClick}>
			Test
		</button>
	);
}

//button that says "Add Row"
function AddRowButton(props){
	return (
		<button onClick={props.onClick}>
			Add Row
		</button>
	);
}

//button that says "Add Column"
function AddColumnButton(props){
	return (
		<button onClick={props.onClick}>
			Add Column
		</button>
	);
}

function Header(props){
	return (
		<tr>
			<td>
				In
			</td>
			{props.cols.map((col, index) => 
										 <ExprCell 
											 key={index}
											 text={col.text}
											 onChange={(e) => props.onChange(e, col)}
											 />)}
		</tr>
	);
}

function Footer(props){
	function renderDelCell(col){
		return (
			<td>
				<button onClick={() => props.onClick(col)}>
					Delete
				</button>
			</td>
		);
	}
	
	return (
		<tr>
			<td>
				You Can't Delete Me
			</td>
			{props.cols.map((col) => 
											<DelCell
												key={Math.round(Math.random() * 100000)}
												onClick={() => props.onClick(col)}
											/>)}
		</tr>
	);
}

class App extends React.Component{
	constructor(props){
		super(props);
		this.state = {rows: [{inValue: 0, inText: '0'}],
								  cols: [{expression: (n) => n, text: '(n) => n'}]};
		
		this.test = this.test.bind(this);
		this.addRow = this.addRow.bind(this);
		this.addColumn = this.addColumn.bind(this);
		this.remRow = this.remRow.bind(this);
		this.remColumn = this.remColumn.bind(this);
		this.inTextChange = this.inTextChange.bind(this);
		this.exprChange = this.exprChange.bind(this);
	}
	
	//evaluates the text fields of each element of the rows, columns
	//puts the result in the relevent fields (inValue, expression respectively)
	test(){
		const cols = this.state.cols.slice();
		//this mapping function changes the array cols
		cols.map((col) => {col.expression = eval(col.text)});
		this.setState({cols: cols});
		
		const rows = this.state.rows.slice();
		//this mapping function changes the array rows
		rows.map((row) => {row.inValue = eval(row.inText)});
		this.setState({rows: rows});
	}
	
	//adds a new row
	addRow(){
		const rows = this.state.rows.slice();
		rows.push({inValue: 0, inText: '0'});
		this.setState({rows: rows});
	}
	
	//adds a new column
	addColumn(){
		const cols = this.state.cols.slice();
		cols.push({expression: (n) => n, text: '(n) => n'});
		this.setState({cols: cols});
	}
	
	//removes a row
	remRow(deadRow){
		//filter out the row we don't want from the rows
		const rows = filter(this.state.rows, (row) => row !== deadRow);
		this.setState({rows: rows});
	}
	
	remColumn(deadCol){
		const cols = filter(this.state.cols, (col) => col !== deadCol);
		this.setState({cols: cols});
	}
	
	//handles changes caused by updating a text field
  inTextChange(e, modRow){
		//this mapping function does not change the array this.state.rows
		//not sure if this actually does anything... still need setState to rerender though
		const rows = this.state.rows.map((row) => row === modRow ? modRow : row);
		modRow.inText = e.target.value;
		this.setState({rows: rows});
	}
	
	exprChange(e, modCol){
		const cols = this.state.cols.map((col) => col === modCol ? modCol : col);
		modCol.text = e.target.value;
		this.setState({cols: cols});
	}
	
	render(){
		return (
			<div>
				<table border="1">
					<tbody>
						<Header 
							cols={this.state.cols} 
							onChange={this.exprChange} 
							/>
						{this.state.rows.map((row, index) => 
																 <IORow 
																	 key={index}
																	 inValue={row.inValue}
																	 inText={row.inText}
																	 expressions={this.state.cols.map((col) => col.expression)}
																	 onChange={(e) => this.inTextChange(e, row)} 
																	 onClick={() => this.remRow(row)}
																	 />)}
						<Footer
							cols={this.state.cols}
							onClick={this.remColumn} 
							/>
					</tbody>
				</table>
				<TestButton onClick={() => this.test()} />
				<AddRowButton onClick={() => this.addRow()} />
				<AddColumnButton onClick={() => this.addColumn()} />
			</div>
		);
	}
}

//thing that decides what to render and where
ReactDOM.render(<App />,
                document.getElementById('root'));
